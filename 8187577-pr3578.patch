# HG changeset patch
# User poonam
# Date 1525279722 -3600
#      Wed May 02 17:48:42 2018 +0100
# Node ID ffd5260fe5adcb26f87a14f1aaaf3e1a075d712a
# Parent  5460c427c0dcb335f510cbc2ea1d76c6921b1aaa
8187577, PR3578: JVM crash during gc doing concurrent marking
Summary: Inform G1's SATB that a klass has been resurrected and it should not be unloaded
Reviewed-by: coleenp, tschatzl, kbarrett

diff --git openjdk.orig/hotspot/src/share/vm/prims/jvmtiGetLoadedClasses.cpp openjdk/hotspot/src/share/vm/prims/jvmtiGetLoadedClasses.cpp
--- openjdk.orig/hotspot/src/share/vm/prims/jvmtiGetLoadedClasses.cpp
+++ openjdk/hotspot/src/share/vm/prims/jvmtiGetLoadedClasses.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,9 @@
 #include "memory/universe.inline.hpp"
 #include "prims/jvmtiGetLoadedClasses.hpp"
 #include "runtime/thread.hpp"
+#if INCLUDE_ALL_GCS
+#include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
+#endif
 
 
 // The closure for GetLoadedClasses
@@ -35,6 +38,20 @@
   Stack<jclass, mtInternal> _classStack;
   JvmtiEnv* _env;
 
+// Tell the GC to keep this klass alive
+static void ensure_klass_alive(oop o) {
+  // A klass that was previously considered dead can be looked up in the
+  // CLD/SD, and its _java_mirror or _class_loader can be stored in a root
+  // or a reachable object making it alive again. The SATB part of G1 needs
+  // to get notified about this potential resurrection, otherwise the marking
+  // might not find the object.
+#if INCLUDE_ALL_GCS
+  if (UseG1GC && o != NULL) {
+    G1SATBCardTableModRefBS::enqueue(o);
+  }
+#endif
+}
+
 public:
   LoadedClassesClosure(JvmtiEnv* env) {
     _env = env;
@@ -43,6 +60,7 @@
   void do_klass(Klass* k) {
     // Collect all jclasses
     _classStack.push((jclass) _env->jni_reference(k->java_mirror()));
+    ensure_klass_alive(k->java_mirror());
   }
 
   int extract(jclass* result_list) {
